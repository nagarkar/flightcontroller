%%%%%%%%%%%%%%%
% getVectorRotation 
%%%%%%%%%%%%%%%
rot = Rotation;
r = rot.getVectorRotation('ZYX', 1, 1, 1);
r_expected = [...
    cos(1)^2                      (cos(1)*sin(1)^2 - cos(1)*sin(1))     (cos(1)^2*sin(1) + sin(1)^2); ...
    cos(1)*sin(1)               (cos(1)^2 + sin(1)^3)                        (cos(1)*sin(1)^2 - cos(1)*sin(1)); ...
    -sin(1)                           cos(1)*sin(1)                                     cos(1)^2 ...
 ];
assert(isalmost(double(vpa(r)), r_expected, .0001, 1));

%%%%%%%%%%%%%%%
% getOmegaRotation 
%%%%%%%%%%%%%%%

r = rot.getOmegaRotation('ZYX', 1, 2, 3);

r_expected = [...
    cos(1)                         0                       -cos(2)*sin(1);...
    0                                  1                        sin(2); ...
    sin(1)                           0                        cos(2)*cos(1) ...
 ];
assert(isalmost(double(vpa(r)), r_expected, .0001, 1));

%%%%%%%%%%%%%%%
% getDesiredRotation3D 
%%%%%%%%%%%%%%%

%Define a1, a2, a3 (unit vectors in inertial frame)
a1 = [1; 0; 0];         a2 = [0; 1; 0];         a3 = [0; 0;1];
% Let say we know thrust vector ‘t’ to be:
t = sind(30)*cosd(45)*a1 + sind(30)*sind(45)*a2 + cosd(30)*a3;
r = rot.getDesiredRotation3D('ZYX', t, [0; 0; 1], pi/4);
r_expected = [ ...
    -0.61237  0.7071 0.35355; ...
    -0.61237 -0.7071 0.35355; ...
    0.5             0           0.86602 ...
];
assert(isalmost(double(vpa(r)), r_expected, .0001, 1));

%%%%%%%%%%%%%%%
% getRotationXMinusY 
%%%%%%%%%%%%%%%
X = [0 0 1; 1 0 0; 0 1 0];
Y = [0.7244    0.1294    0.6771; ...
    0.6424   -0.4830   -0.5950; ...
    0.2500    0.8660   -0.4330];
r = rot.getRotationXMinusY(X, Y);
r_expected = [ ...
    0.6424    0.2500    0.7244; ...
   -0.4830    0.8660    0.1294; ...
   -0.5950   -0.4330    0.6771];
assert(rot.AisalmostB(r_expected, r));

%%%%%%%%%%%%%%%
% getAngularFixedVelFromEulerRates 
%%%%%%%%%%%%%%%

r = rot.getAngularBodyVelFromEulerRates('ZYX', [1/2; 1/2; 1/2], [1; 2; 3]);
r_expected = [ ...
    cos(2)/2 - (cos(1)*sin(2))/2;...
    sin(1)/2 + 1/2;...
    sin(2)/2 + (cos(1)*cos(2))/2];
assert(rot.AisalmostB(r_expected, r));
