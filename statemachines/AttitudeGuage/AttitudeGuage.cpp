//****************************************************************************
// Model: NineAxisMeasurement.qm
// File:  AttitudeGuage/AttitudeGuage.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${AttitudeGuage::AttitudeGuage::AttitudeGuage.cpp} .........................
#include "AttitudeGuage.h"

#include "x_nucleo_iks01a1_accelero.h"
#include "app_ao_config.h"
#include "active_log.h"

using namespace StdEvents;
using namespace QP;

extern "C" void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
   if (GPIO_Pin != GPIO_PIN_5) {
        return;
   }
   QF::PUBLISH(new Evt(ATTITUDE_DATA_AVAILABLE_SIG), NULL);
}

namespace Attitude {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${AttitudeGuage::AttitudeGuage} ............................................
//${AttitudeGuage::AttitudeGuage::AttitudeGuage} .............................
AttitudeGuage::AttitudeGuage()
  : AO(ATTITUDE_GUAGE_INTERVAL_TIMER_SIG,
        (QStateHandler)&initial,
        "ATTITUDE_GUAGE")
    , m_gyroRate(0)
{}

//${AttitudeGuage::AttitudeGuage::Init} ......................................
status_t AttitudeGuage::Init() {
    uint32_t prim = __get_PRIMASK();
    //__disable_irq();
    volatile status_t status;
    DrvStatusTypeDef result = COMPONENT_OK;
    status = AttitudeUtils::Initialize(result, &m_acc_handle);
    if (status == MEMS_ERROR) {
        PRINT("ERROR in AttitudeGuage.Init()");
        ErrorEvt *evt = new ErrorEvt(ATTITUDE_GUAGE_FAILED_SIG, 0, ERROR_HARDWARE);
        postLIFO(evt);
    }
    if (!prim) {
    //    __enable_irq();
    }
    return MEMS_SUCCESS;
}
//${AttitudeGuage::AttitudeGuage::UpdateGyroRate} ............................
void AttitudeGuage::UpdateGyroRate() {
    static uint32_t numDelays = 0;
    numDelays++;
    int totalTime = numDelays * CHECK_UP_INTERVAL;
    // TODO: Deal with overflow
    m_gyroRate = (1.0 * m_measurements)/totalTime; // Hz
    m_previousMeasurementCount = m_measurements;
}
//${AttitudeGuage::AttitudeGuage::GotNewMeasurements} ........................
bool AttitudeGuage::GotNewMeasurements() {
    bool result = true;
    if (m_previousMeasurementCount == m_measurements) {
        result = false;
    }
    m_previousMeasurementCount = m_measurements;
    return result;
}
//${AttitudeGuage::AttitudeGuage::ProcessAttitude} ...........................
void AttitudeGuage::ProcessAttitude() {
    Acceleration linearAcc;
    AngularRate angularRate;

    status_t status = AttitudeUtils::GetAttitude(
        linearAcc, angularRate, m_acc_handle);

    if (status == MEMS_ERROR) {
        postLIFO(new Evt(ATTITUDE_GUAGE_FAILED_SIG));
        return;
    }

    //Evt *evt = new AttitudeDataEvt(linearAcc, angularRate);
    //QF::PUBLISH(evt, this);

    m_measurements++;
}
//${AttitudeGuage::AttitudeGuage::SM} ........................................
QP::QState AttitudeGuage::initial(AttitudeGuage * const me, QP::QEvt const * const e) {
    // ${AttitudeGuage::AttitudeGuage::SM::initial}
    me->subscribe(ATTITUDE_GUAGE_STOP_REQ_SIG);
    //me->subscribe(ATTITUDE_GUAGE_STOP_CFM_SIG);
    me->subscribe(ATTITUDE_GUAGE_START_REQ_SIG);
    //me->subscribe(ATTITUDE_GUAGE_START_CFM_SIG);
    //me->subscribe(ATTITUDE_GUAGE_INTERVAL_TIMER_SIG);
    //me->subscribe(ATTITUDE_GUAGE_FAILED_SIG);
    me->subscribe(ATTITUDE_DATA_AVAILABLE_SIG);

    return Q_TRAN(&Root);
}
//${AttitudeGuage::AttitudeGuage::SM::Root} ..................................
QP::QState AttitudeGuage::Root(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Stopped);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Stopped} .........................
QP::QState AttitudeGuage::Stopped(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Stopped}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Stopped::ATTITUDE_GUAGE_START_REQ}
        case ATTITUDE_GUAGE_START_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_START_CFM_SIG);
            status_ = Q_TRAN(&Started);
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Stopped::ATTITUDE_GUAGE_STOP_REQ}
        case ATTITUDE_GUAGE_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_STOP_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Started} .........................
QP::QState AttitudeGuage::Started(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            me->m_timer.armX(CHECK_UP_INTERVAL, CHECK_UP_INTERVAL);
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started}
        case Q_EXIT_SIG: {
            me->m_timer.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&CollectingData);
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::ATTITUDE_GUAGE_STOP_REQ}
        case ATTITUDE_GUAGE_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_STOP_CFM_SIG);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::ATTITUDE_GUAGE_START_REQ}
        case ATTITUDE_GUAGE_START_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_START_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Started::Failed} .................
QP::QState AttitudeGuage::Failed(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::Failed}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            static uint8_t retries = 0;
            //me->m_timer.disarm();
            if (retries < MAX_RETRIES) {
                retries++;
            } else {
                PRINT("Exhaused Retries");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Started::CollectingData} .........
QP::QState AttitudeGuage::CollectingData(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::CollectingData}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_t status = me->Init();
            if (status == MEMS_ERROR) {
              me->postLIFO(new Evt(ATTITUDE_GUAGE_FAILED_SIG));
            }
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::CollectingData::ATTITUDE_DATA_AVAILABLE}
        case ATTITUDE_DATA_AVAILABLE_SIG: {
            me->ProcessAttitude();
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::CollectingData::ATTITUDE_GUAGE_FAILED}
        case ATTITUDE_GUAGE_FAILED_SIG: {
            LOG_EVENT(e);
            status_ = Q_TRAN(&Failed);
            break;
        }
        default: {
            status_ = Q_SUPER(&Started);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeDataEvt} ..........................................
//${AttitudeGuage::AttitudeDataEvt::AttitudeDataEvt} .........................
AttitudeDataEvt::AttitudeDataEvt(Acceleration acc, AngularRate angularRate)
 : Evt(ATTITUDE_CHANGED_SIG)
    , m_acc(acc)
    , m_angularRate(angularRate)
{}

} // namespace Attitude
