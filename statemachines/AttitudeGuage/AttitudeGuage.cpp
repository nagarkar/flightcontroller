//****************************************************************************
// Model: NineAxisMeasurement.qm
// File:  AttitudeGuage/AttitudeGuage.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${AttitudeGuage::AttitudeGuage::AttitudeGuage.cpp} .........................
#include "AttitudeGuage.h"

#include "x_nucleo_iks01a1_accelero.h"
#include "app_ao_config.h"
#include "active_log.h"

using namespace StdEvents;
using namespace QP;

namespace Attitude {

AttitudeGuage *attitudeGuage = NULL;

extern "C" void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    if (GPIO_Pin != GPIO_PIN_5) {
        return;
    }
    if (attitudeGuage != NULL && attitudeGuage->ProcessAttitude() == MEMS_SUCCESS) {
        QF::PUBLISH(new Evt(ATTITUDE_DATA_AVAILABLE_SIG), NULL);
    }
}

} // Namespace

namespace Attitude {


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpcpp version 5.8.0 or higher required
#endif

//${AttitudeGuage::AttitudeGuage} ............................................
//${AttitudeGuage::AttitudeGuage::AttitudeGuage} .............................
AttitudeGuage::AttitudeGuage()
  : AO(ATTITUDE_GUAGE_INTERVAL_TIMER_SIG,
        (QStateHandler)&initial,
        "ATTITUDE_GUAGE")
    , m_gyroRate(0)
	, m_measurements(0)
	, m_previousMeasurementCount(0)
	, m_acc_handle(NULL)
{
	attitudeGuage = this;
}

//${AttitudeGuage::AttitudeGuage::Init} ......................................
status_t AttitudeGuage::Init() {
    volatile status_t status;
    DrvStatusTypeDef result = COMPONENT_OK;
    status = AttitudeUtils::Initialize(result, &m_acc_handle);
    if (status == MEMS_ERROR) {
        PRINT("ERROR in AttitudeGuage.Init()\r\n");
        //ErrorEvt *evt = new ErrorEvt(ATTITUDE_GUAGE_FAILED_SIG, 0, ERROR_HARDWARE);
        //postLIFO(evt);
    }
    return status;
}
//${AttitudeGuage::AttitudeGuage::UpdateGyroRate} ............................
void AttitudeGuage::UpdateGyroRate() {
    static uint32_t numDelays = 0;
    numDelays++;
    int totalMillis = numDelays * CHECK_UP_INTERVAL;
    // TODO: Deal with overflow
    m_gyroRate = (1000.0 * m_measurements)/totalMillis; // Hz
}
//${AttitudeGuage::AttitudeGuage::GotNewMeasurements} ........................
bool AttitudeGuage::GotNewMeasurements() {
    if (m_previousMeasurementCount == m_measurements) {
        return false;
    } else {
        m_previousMeasurementCount = m_measurements;
        return true;
    }
}
//${AttitudeGuage::AttitudeGuage::ProcessAttitude} ...........................
status_t AttitudeGuage::ProcessAttitude() {
    Acceleration linearAcc;
    AngularRate angularRate;

    status_t status = AttitudeUtils::GetAttitude(
        linearAcc, angularRate, m_acc_handle);

    if (status == MEMS_ERROR) {
        //postLIFO(new Evt(ATTITUDE_GUAGE_FAILED_SIG));
    } else {
        m_measurements++;
        Evt *evt = new AttitudeDataEvt(linearAcc, angularRate);
        QF::PUBLISH(evt, this);
    }
    return status;
}
//${AttitudeGuage::AttitudeGuage::Start} .....................................
uint8_t AttitudeGuage::Start(uint8_t prio) {
    if (Init() != MEMS_SUCCESS || AO::Start(prio) < 0) {
        return -1;
    }
    return 0;
}
//${AttitudeGuage::AttitudeGuage::SM} ........................................
QP::QState AttitudeGuage::initial(AttitudeGuage * const me, QP::QEvt const * const e) {
    // ${AttitudeGuage::AttitudeGuage::SM::initial}
    me->subscribe(ATTITUDE_GUAGE_STOP_REQ_SIG);
    me->subscribe(ATTITUDE_GUAGE_START_REQ_SIG);
    me->subscribe(ATTITUDE_DATA_AVAILABLE_SIG);
    me->subscribe(ATTITUDE_GUAGE_FAILED_SIG);
    return Q_TRAN(&Root);
}
//${AttitudeGuage::AttitudeGuage::SM::Root} ..................................
QP::QState AttitudeGuage::Root(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::initial}
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&Stopped);
            break;
        }
        default: {
            status_ = Q_SUPER(&top);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Stopped} .........................
QP::QState AttitudeGuage::Stopped(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Stopped}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Stopped::ATTITUDE_GUAGE_START_REQ}
        case ATTITUDE_GUAGE_START_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_START_CFM_SIG);
            status_ = Q_TRAN(&Started);
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Stopped::ATTITUDE_GUAGE_STOP_REQ}
        case ATTITUDE_GUAGE_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_STOP_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Started} .........................
QP::QState AttitudeGuage::Started(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            me->m_timer.armX(CHECK_UP_INTERVAL, CHECK_UP_INTERVAL);
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started}
        case Q_EXIT_SIG: {
            me->m_timer.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::ATTITUDE_GUAGE_STOP_REQ}
        case ATTITUDE_GUAGE_STOP_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_STOP_CFM_SIG);
            status_ = Q_TRAN(&Stopped);
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::ATTITUDE_GUAGE_START_REQ}
        case ATTITUDE_GUAGE_START_REQ_SIG: {
            LOG_EVENT(e);
            me->PublishConfirmation(
                EVT_CAST(*e),
                ATTITUDE_GUAGE_START_CFM_SIG);
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::ATTITUDE_GUAGE_INTERVAL_TIMER}
        case ATTITUDE_GUAGE_INTERVAL_TIMER_SIG: {
            LOG_EVENT(e);
            if(!me->GotNewMeasurements()) {
                me->postLIFO(new Evt(ATTITUDE_GUAGE_FAILED_SIG));
            } else {
            	me->UpdateGyroRate();
            	PRINT("GYRO Rate: %d\r\n", me->m_gyroRate);
            }
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Started::ATTITUDE_GUAGE_FAILED}
        case ATTITUDE_GUAGE_FAILED_SIG: {
            status_ = Q_TRAN(&Failed);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeGuage::SM::Root::Failed} ..........................
QP::QState AttitudeGuage::Failed(AttitudeGuage * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Failed}
        case Q_ENTRY_SIG: {
            LOG_EVENT(e);
            uint8_t retries = 0;
            status_t status = MEMS_ERROR;
            while(retries < MAX_RETRIES && status == MEMS_ERROR) {
                retries++;
                QF_CRIT_ENTRY(0);
                status = me->Init();
                if (status == MEMS_ERROR) {
                    continue;
                }
                status = me->ProcessAttitude();
                QF_CRIT_EXIT(0);
                if (status == MEMS_SUCCESS) {
                    break;
                }
            }
            if (status == MEMS_ERROR && retries == MAX_RETRIES) {
                PRINT("Exhaused Retries\r\n");
            }
            status_ = Q_HANDLED();
            break;
        }
        // ${AttitudeGuage::AttitudeGuage::SM::Root::Failed::ATTITUDE_DATA_AVAILABLE}
        case ATTITUDE_DATA_AVAILABLE_SIG: {
            status_ = Q_TRAN(&Started);
            break;
        }
        default: {
            status_ = Q_SUPER(&Root);
            break;
        }
    }
    return status_;
}
//${AttitudeGuage::AttitudeDataEvt} ..........................................
//${AttitudeGuage::AttitudeDataEvt::AttitudeDataEvt} .........................
AttitudeDataEvt::AttitudeDataEvt(Acceleration acc, AngularRate angularRate)
 : Evt(ATTITUDE_CHANGED_SIG)
    , m_acc(acc)
    , m_angularRate(angularRate)
{}

} // namespace Attitude
