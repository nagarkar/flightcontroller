//****************************************************************************
// Model: BSP_STMF4XRE_HAL.qm
// File:  bsp_stmf4xre_hal/bsp.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${BSP::bsp_stmf4xre_hal::bsp.cpp} ..........................................
#include "bsp.h"
#include "usart.h"
#include "gpio.h"
#include "macros.h"
#include "qpcpp.h"

#define MAX_RESET_COUNT_BEFORE_FAILURE 100

#ifdef __cplusplus
 extern "C" {
#endif

extern void initialise_monitor_handles(void);

RTC_HandleTypeDef hrtc;
void MX_RTC_Init(void);

#define QF_CRIT_STAT_TYPE void *

/*** Private Function Prototypes **/
/**/

__weak void BSP_Init() {
    BSP_InitPerfMarker();
#if defined(SEMIHOSTING_ENABLED)
    BSP_Initialize_Semihosting();
#endif
    MX_RTC_Init();
	uint32_t resetCount = HAL_RTCEx_BKUPRead(&hrtc, RESETCOUNT_REG);
	// If Reset Count > 5, it means we are starting from a power-on, so reset it to 0
	if (resetCount > 5) {
		HAL_RTCEx_BKUPWrite(&hrtc, RESETCOUNT_REG, 0);
	}
}

__weak void BSP_SystemResetOrLoop() {
	uint32_t resetCount = HAL_RTCEx_BKUPRead(&hrtc, RESETCOUNT_REG);
	if (resetCount < MAX_RESET_COUNT_BEFORE_FAILURE) {
		HAL_RTCEx_BKUPWrite(&hrtc, RESETCOUNT_REG, resetCount + 1);
		NVIC_SystemReset();
	} else {
		while(0==0){};
	}

}

void MX_RTC_Init(void) {
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK) {
    Error_Handler();
  }
}

__weak void BSP_I2C1_MspInit(I2C_HANDLE_TYPE_DEF* i2cHandle) {
	(void)0;
}

__weak void BSP_I2C3_MspInit(I2C_HANDLE_TYPE_DEF* i2cHandle) {
	(void)0;
}

/** Follow the steps given in section 2.14.7 of the stm32Fxx errata sheet:
	1. Disable the I2C peripheral by clearing the PE bit in I2Cx_CR1 register.
	2. Configure the SCL and SDA I/Os as General Purpose Output Open-Drain, High level
	(Write 1 to GPIOx_ODR).
	3. Check SCL and SDA High level in GPIOx_IDR.
	4. Configure the SDA I/O as General Purpose Output Open-Drain, Low level (Write 0 to
	GPIOx_ODR).
	5. Check SDA Low level in GPIOx_IDR.
	6. Configure the SCL I/O as General Purpose Output Open-Drain, Low level (Write 0 to
	GPIOx_ODR).
	7. Check SCL Low level in GPIOx_IDR.
	8. Configure the SCL I/O as General Purpose Output Open-Drain, High level (Write 1 to
	GPIOx_ODR).
	9. Check SCL High level in GPIOx_IDR.
	10. Configure the SDA I/O as General Purpose Output Open-Drain , High level (Write 1 to
	GPIOx_ODR).
	11. Check SDA High level in GPIOx_IDR.
	12. Configure the SCL and SDA I/Os as Alternate function Open-Drain.
	13. Set SWRST bit in I2Cx_CR1 register.
	14. Clear SWRST bit in I2Cx_CR1 register.
	15. Enable the I2C peripheral by setting the PE bit in I2Cx_CR1 register.

	This function only runs when the key symptom, hte busy flag being set, is true. It only
	runs once.

	Also see
	**/
void BSP_I2C_ClearBusyFlagErrata_2_14_7(I2C_HandleTypeDef *hi2c, uint32_t sda_pin, uint32_t scl_pin ) {

	static uint8_t resetTried = 0;
	static uint8_t verify = 1;
	if (resetTried == 1) {
		return;
	}
	if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != SET) {
		return;
	}
	GPIO_InitTypeDef GPIO_InitStruct;

	// 1
	__HAL_I2C_DISABLE(hi2c);

	// 2
	GPIO_InitStruct.Pin = sda_pin|scl_pin;
	HAL_GPIO_DeInit(GPIOB, sda_pin);
	HAL_GPIO_DeInit(GPIOB, scl_pin);

	__HAL_RCC_GPIOB_CLK_DISABLE();

	__HAL_RCC_GPIOB_CLK_ENABLE();

	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	BSP_GPIO_WRITE_ODR(GPIOB, sda_pin);
	BSP_GPIO_WRITE_ODR(GPIOB, scl_pin);

	// 3
	if (verify && HAL_GPIO_ReadPin(GPIOB, sda_pin) == GPIO_PIN_RESET) {
		BSP_SystemResetOrLoop();
	}
	if (verify && HAL_GPIO_ReadPin(GPIOB, scl_pin) == GPIO_PIN_RESET) {
		BSP_SystemResetOrLoop();
	}

	// 4
	GPIO_InitStruct.Pin = sda_pin;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	HAL_GPIO_TogglePin(GPIOB, sda_pin);

	// 5
	if (verify && HAL_GPIO_ReadPin(GPIOB, sda_pin) == GPIO_PIN_SET) {
		BSP_SystemResetOrLoop();
	}

	// 6
	GPIO_InitStruct.Pin = scl_pin;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	HAL_GPIO_TogglePin(GPIOB, scl_pin);

	// 7
	if (verify && HAL_GPIO_ReadPin(GPIOB, scl_pin) == GPIO_PIN_SET) {
		BSP_SystemResetOrLoop();
	}

	// 8
	GPIO_InitStruct.Pin = sda_pin;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	BSP_GPIO_WRITE_ODR(GPIOB, sda_pin);

	// 9
	if (verify && HAL_GPIO_ReadPin(GPIOB, sda_pin) == GPIO_PIN_RESET) {
		BSP_SystemResetOrLoop();
	}
}


void BSP_GPIO_WRITE_ODR(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR |= GPIO_Pin;
}

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle) {
  if(rtcHandle->Instance==RTC) {
    __HAL_RCC_RTC_ENABLE();
  }
}

void HAL_RTC_MspDeInit(RTC_HandleTypeDef* rtcHandle) {
  if(rtcHandle->Instance==RTC) {
    __HAL_RCC_RTC_DISABLE();
  }
}

__weak void BSP_OVERRIDE_UART2_CALLBACKS(USART_HANDLE_TYPE_DEF *uart) {
	(void)0;
}

__weak void BSP_OVERRIDE_UART_CALLBACKS(USART_HANDLE_TYPE_DEF *uart) {
	//TODO: Check if it's UARTx before calling BSP_OVERRIDE_UARTX_CALLBACKS(uartx);
	BSP_OVERRIDE_UART2_CALLBACKS(uart);
	(void)0;
}

__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority) {
    (void)TickPriority;
    SysTick_Config(SystemCoreClock / BSP_TICKS_PER_SEC);
    HAL_NVIC_SetPriority(SysTick_IRQn, 0, /* Higher than DMA, UART etc */3);
    return HAL_OK;
}

__weak void BSP_InitPerfMarker() {
    DWT->CYCCNT = 0;
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
}

__weak void BSP_Initialize_Semihosting() {
    //initialise_monitor_handles();
}

static uint16_t PRINTF_BUF_LEN = 200;
__weak void BSP_Printf(char const *format, ...) {
    va_list arg;
    va_start(arg, format);
    char buf[PRINTF_BUF_LEN];
    uint32_t len = vsnprintf(buf, ARRAY_COUNT(buf), format, arg);
    va_end(arg);
    len = LESS(len, ARRAY_COUNT(buf) - 1);
    HAL_UART_Transmit(&huart2, (uint8_t *) buf, len, 0xFFFF);
}

__weak void BSP_LED_DeInit(uint16_t LED) {
    (void)LED;
}

__weak void BSP_LED_Init(uint16_t LED) {
    (void)LED;
}

__weak void BSP_LED_On(uint16_t LED) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
}

__weak void BSP_LED_Off(uint16_t LED) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
}

__weak void BSP_Delay(volatile uint32_t delay) {
    HAL_Delay(delay);
}

__weak void BSP_DisableRxInt(USART_HANDLE_TYPE_DEF *uart) {
    QF_CRIT_STAT_TYPE crit;
    QF_CRIT_ENTRY(crit);
    CLEAR_BIT(uart->Instance->CR1, USART_CR1_RXNEIE);
    QF_CRIT_EXIT(crit);
}

__weak void BSP_EnableRxInt(USART_HANDLE_TYPE_DEF *uart) {
    // Enable Data Register not empty Interrupt.
    QF_CRIT_STAT_TYPE crit;
    QF_CRIT_ENTRY(crit);
    SET_BIT(uart->Instance->CR1, USART_CR1_RXNEIE);
    QF_CRIT_EXIT(crit);
}

__weak uint32_t BSP_GetCountOfRemainingDmaXferUnits(USART_HANDLE_TYPE_DEF *uart) {
    return __HAL_DMA_GET_COUNTER(uart->hdmarx);
}

#ifdef __cplusplus
 }
#endif

