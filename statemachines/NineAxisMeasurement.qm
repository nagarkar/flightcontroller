<?xml version="1.0" encoding="UTF-8"?>
<model version="4.0.1" links="0">
 <framework name="qpcpp"/>
 <package file="./std_events.qmp"/>
 <package name="AttitudeGuage" stereotype="0x02" namespace="Attitude::">
  <class name="AttitudeGuage" superclass="StdEvents::AO">
   <attribute name="m_acc_handle" type="void *" visibility="0x02" properties="0x00"/>
   <attribute name="m_mag_handle" type="void *" visibility="0x02" properties="0x00"/>
   <attribute name="m_bar_handle" type="void *" visibility="0x02" properties="0x00"/>
   <attribute name="m_gyroRate" type="float" visibility="0x02" properties="0x00"/>
   <attribute name="m_measurements" type="uint32_t" visibility="0x02" properties="0x00"/>
   <attribute name="m_measurementsAltitude" type="uint32_t" visibility="0x02" properties="0x00"/>
   <attribute name="{ CHECK_UP_INTERVAL = 1000, MAX_RETRIES = 5, MAX_INIT_ATTEMPTS_BEFORE_RESET = 5}" type="enum " visibility="0x02" properties="0x00"/>
   <attribute name="m_previousMeasurementCount" type="uint32_t" visibility="0x02" properties="0x00"/>
   <attribute name="m_previousAltitudeMeasurementCount" type="uint32_t" visibility="0x02" properties="0x00"/>
   <attribute name="m_acc_gyro_data[12]" type="u8_t" visibility="0x02" properties="0x00"/>
   <attribute name="m_acc" type="Acceleration" visibility="0x02" properties="0x00"/>
   <attribute name="m_angularRate" type="AngularRate" visibility="0x02" properties="0x00"/>
   <attribute name="m_field" type="MagneticField" visibility="0x02" properties="0x00"/>
   <attribute name="m_altitude" type="Altitude" visibility="0x02" properties="0x00"/>
   <attribute name="m_attitude" type="Q_cxyz" visibility="0x02" properties="0x00"/>
   <attribute name="default_acc_gyro_data[12]" type="u8_t" visibility="0x00" properties="0x00"/>
   <operation name="AttitudeGuage" type="" visibility="0x00" properties="0x00">
    <code>  : AO(ATTITUDE_GUAGE_INTERVAL_TIMER_SIG,
        (QStateHandler)&amp;initial,
        &quot;ATTITUDE_GUAGE&quot;)
    , m_gyroRate(0)
    , m_measurements(0)
    , m_previousMeasurementCount(0)
    , m_acc_handle(NULL)
    , m_mag_handle(NULL)
    , m_bar_handle(NULL)
    , m_acc_gyro_data({0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
    , default_acc_gyro_data({0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
    , m_attitude({1.0f, 0.0f, 0.0f, 0.0f})</code>
   </operation>
   <operation name="Init" type="status_t" visibility="0x00" properties="0x00">
    <documentation>docs</documentation>
    <code>static int initializationAttempts = 0;
volatile status_t status;
DrvStatusTypeDef result = COMPONENT_OK;
status = AttitudeUtils::Initialize(result, &amp;m_acc_handle, &amp;m_mag_handle, &amp;m_bar_handle);
initializationAttempts++;
if (initializationAttempts &gt; MAX_INIT_ATTEMPTS_BEFORE_RESET) {
    BSP_SystemResetOrLoop();
}
if (status == MEMS_ERROR) {
    PRINT(&quot;ERROR in AttitudeGuage.Init()\r\n&quot;);
    ErrorEvt *evt = new ErrorEvt(ATTITUDE_COLLECTION_FAILED_SIG, INITIALIZATION_FAILED, ERROR_HARDWARE);
    postLIFO(evt);
}
return status;</code>
   </operation>
   <operation name="InitBarometer" type="status_t" visibility="0x00" properties="0x00">
    <documentation>docs</documentation>
    <code>static int barometerInitializationAttempts = 0;
volatile status_t status;
DrvStatusTypeDef result = COMPONENT_OK;
status = AttitudeUtils::InitializeBarometer(result, &amp;m_bar_handle);
barometerInitializationAttempts++;
if (barometerInitializationAttempts &gt; MAX_INIT_ATTEMPTS_BEFORE_RESET) {
    BSP_SystemResetOrLoop();
}
if (status == MEMS_ERROR) {
    PRINT(&quot;ERROR in AttitudeGuage.Init()\r\n&quot;);
    ErrorEvt *evt = new ErrorEvt(BAR_COLLECTION_FAILED_SIG, INITIALIZATION_FAILED, ERROR_HARDWARE);
    postLIFO(evt);
}
return status;</code>
   </operation>
   <operation name="GotNewMeasurements" type="bool" visibility="0x00" properties="0x00">
    <code>if (m_previousMeasurementCount == m_measurements) {
    return false;
} else {
    m_previousMeasurementCount = m_measurements;
    return true;
}</code>
   </operation>
   <operation name="GotNewAltitudeMeasurements" type="bool" visibility="0x00" properties="0x00">
    <code>if (m_previousAltitudeMeasurementCount == m_measurementsAltitude) {
    return false;
} else {
    m_previousAltitudeMeasurementCount = m_measurementsAltitude;
    return true;
}</code>
   </operation>
   <operation name="ProcessAttitude" type="status_t" visibility="0x00" properties="0x00">
    <code>//status_t status = AttitudeUtils::GetAttitude(
//    linearAcc, angularRate, field, m_acc_handle, m_mag_handle);
if (memcmp(m_acc_gyro_data, default_acc_gyro_data, sizeof(default_acc_gyro_data)) == 0){
  return MEMS_SUCCESS;
}
status_t status = AttitudeUtils::GetAttitude2(m_acc_gyro_data, m_acc, m_angularRate, m_field, m_altitude, &amp;m_attitude);

if (status == MEMS_ERROR) {
    ErrorEvt *evt = new ErrorEvt(ATTITUDE_COLLECTION_FAILED_SIG, PROCESSING_ALTITUDE_FAILED, ERROR_HARDWARE);
    postLIFO(evt);
} else {
    m_measurements++;
    Evt *evt = new AttitudeDataEvt(m_acc, m_angularRate, m_field);
    QF::PUBLISH(evt, this);
}
return status;</code>
   </operation>
   <operation name="ProcessAltitude" type="status_t" visibility="0x00" properties="0x00">
    <code>status_t status = AttitudeUtils::ReadAltitude(m_bar_handle, m_altitude);
if (status == MEMS_ERROR) { // Doesn't matter if we don't get altitude as long as there are no gyro measurements.
    ErrorEvt *evt = new ErrorEvt(BAR_COLLECTION_FAILED_SIG, PROCESSING_ALTITUDE_FAILED, ERROR_HARDWARE);
    postLIFO(evt);
} else {
    m_measurementsAltitude++;
    // TODO: Publish a message with altitude.
}
return status;</code>
   </operation>
   <operation name="Start" type="uint8_t" visibility="0x00" properties="0x00">
    <parameter name="prio" type="uint8_t"/>
    <code>return AO::Start(prio);</code>
   </operation>
   <operation name="UpdateGyroRate" type="void" visibility="0x00" properties="0x00">
    <code>static uint32_t numDelays = 0;
numDelays++;
int totalMillis = numDelays * CHECK_UP_INTERVAL;
// TODO: Deal with overflow
m_gyroRate = (1000.0 * m_measurements)/totalMillis; // Hz</code>
   </operation>
   <operation name="StartDMATransfer" type="status_t" visibility="0x02" properties="0x00">
    <code>uint32_t dmaLength = sizeof(default_acc_gyro_data);
memcpy(m_acc_gyro_data, default_acc_gyro_data, dmaLength);
return AttitudeUtils::StartDMATransfer(m_field, m_altitude, m_acc_handle, m_mag_handle, m_bar_handle, m_acc_gyro_data, 12);</code>
   </operation>
   <statechart>
    <initial target="../1">
     <action brief="SubscribeEvents">me-&gt;subscribe(ATTITUDE_GUAGE_STOP_REQ_SIG);
me-&gt;subscribe(ATTITUDE_GUAGE_START_REQ_SIG);
me-&gt;subscribe(ATTITUDE_DATA_AVAILABLE_SIG);
me-&gt;subscribe(ATTITUDE_COLLECTION_FAILED_SIG);
me-&gt;subscribe(ATTITUDE_GYRO_DMA_COMPLETE_SIG);
me-&gt;subscribe(BAR_DATA_AVAILABLE_SIG);
me-&gt;subscribe(BAR_COLLECTION_FAILED_SIG);</action>
     <initial_glyph conn="3,3,5,0,11,2">
      <action box="0,-2,15,2"/>
     </initial_glyph>
    </initial>
    <state name="Root">
     <documentation>Documentation</documentation>
     <initial target="../4">
      <initial_glyph conn="33,8,5,0,-20,1">
       <action box="0,-2,10,2"/>
      </initial_glyph>
     </initial>
     <state name="Started">
      <entry brief="ArmX">LOG_EVENT(e);
me-&gt;m_timer.armX(CHECK_UP_INTERVAL, CHECK_UP_INTERVAL);</entry>
      <exit brief="DisarmX">me-&gt;m_timer.disarm();</exit>
      <tran trig="ATTITUDE_GUAGE_STOP_REQ" target="../../4">
       <action brief="^CFM">LOG_EVENT(e);
me-&gt;PublishConfirmation(
    EVT_CAST(*e),
    ATTITUDE_GUAGE_STOP_CFM_SIG);</action>
       <tran_glyph conn="48,29,0,2,-4,13,-4,-16,-4">
        <action box="-5,-7,26,3"/>
       </tran_glyph>
      </tran>
      <tran trig="ATTITUDE_GUAGE_START_REQ">
       <action brief="^CFM">LOG_EVENT(e);
me-&gt;PublishConfirmation(
    EVT_CAST(*e),
    ATTITUDE_GUAGE_START_CFM_SIG);</action>
       <tran_glyph conn="9,43,3,-1,39">
        <action box="0,-2,30,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ATTITUDE_GUAGE_INTERVAL_TIMER">
       <action brief="CheckIfValid, ^FAILED">if(!me-&gt;GotNewMeasurements()) {
    ErrorEvt *evt = new ErrorEvt(ATTITUDE_COLLECTION_FAILED_SIG, NO_NEW_MEASUREMENTS_DETECTED, ERROR_HARDWARE);
    me-&gt;postLIFO(evt);
} else {
    me-&gt;UpdateGyroRate();
    PRINT(&quot;GYRO Rate: %f\r\n&quot;, me-&gt;m_gyroRate);
    if(!me-&gt;GotNewAltitudeMeasurements()) {
        ErrorEvt *evt = new ErrorEvt(BAR_COLLECTION_FAILED_SIG, NO_NEW_MEASUREMENTS_DETECTED, ERROR_HARDWARE);
        me-&gt;postLIFO(evt);
    }
    // TODO: Measure Altitude Rate, same as Gyro me-&gt;UpdateAltitudeRate();
    // PRINT(&quot;Altitude Rate: %f\r\n&quot;, me-&gt;m_altitudeRate);
}</action>
       <tran_glyph conn="9,38,3,-1,39">
        <action box="1,-2,31,4"/>
       </tran_glyph>
      </tran>
      <tran trig="ATTITUDE_COLLECTION_FAILED" target="../../2">
       <action>ErrorEvt *err = (ErrorEvt *)e;
PRINTE(err);</action>
       <tran_glyph conn="50,33,1,0,31,2">
        <action box="0,-2,24,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ATTITUDE_DATA_AVAILABLE">
       <action>me-&gt;StartDMATransfer();</action>
       <tran_glyph conn="50,52,1,-1,-37">
        <action box="-27,-2,25,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ATTITUDE_GYRO_DMA_COMPLETE">
       <action>me-&gt;ProcessAttitude();</action>
       <tran_glyph conn="9,47,3,-1,39">
        <action box="1,0,27,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BAR_DATA_AVAILABLE">
       <action>me-&gt;ProcessAltitude();</action>
       <tran_glyph conn="50,56,1,-1,-37">
        <action box="-27,-2,25,2"/>
       </tran_glyph>
      </tran>
      <tran trig="BAR_COLLECTION_FAILED" target="../../3">
       <action>ErrorEvt *err = (ErrorEvt *)e;
PRINTE(err);</action>
       <tran_glyph conn="50,50,1,3,26">
        <action box="0,-2,26,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="9,29,41,31">
       <entry box="1,2,17,2"/>
       <exit box="1,4,12,2"/>
      </state_glyph>
     </state>
     <state name="AttitudeFailed">
      <entry brief="Retry">LOG_EVENT(e);
uint8_t retries = 0;
status_t status = MEMS_ERROR;
while(retries &lt; MAX_RETRIES &amp;&amp; status == MEMS_ERROR) {
    retries++;
    status = me-&gt;Init();
    if (status == MEMS_SUCCESS) {
        me-&gt;postLIFO(new Evt(ATTITUDE_DATA_AVAILABLE_SIG));
        break;
    }
}
if (status == MEMS_ERROR &amp;&amp; retries == MAX_RETRIES) {
    PRINT(&quot;Exhaused Retries\r\n&quot;);
}</entry>
      <tran trig="ATTITUDE_DATA_AVAILABLE" target="../../1">
       <action>me-&gt;StartDMATransfer();</action>
       <tran_glyph conn="80,42,2,1,2,-30">
        <action box="-30,-1,25,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="76,35,14,7">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="BarometerFailed">
      <entry brief="Retry">LOG_EVENT(e);
uint8_t retries = 0;
status_t status = MEMS_ERROR;
while(retries &lt; MAX_RETRIES &amp;&amp; status == MEMS_ERROR) {
    retries++;
    status = me-&gt;InitBarometer();
    if (status == MEMS_SUCCESS) {
        me-&gt;postLIFO(new Evt(BAR_DATA_AVAILABLE_SIG));                    
        break;
    }
}
if (status == MEMS_ERROR &amp;&amp; retries == MAX_RETRIES) {
    PRINT(&quot;Exhaused Retries\r\n&quot;);
}</entry>
      <tran trig="BAR_DATA_AVAILABLE" target="../../1">
       <action>me-&gt;ProcessAltitude();</action>
       <tran_glyph conn="86,56,2,1,2,-36">
        <action box="-30,-1,25,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="76,49,15,7">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state name="Stopped">
      <entry>LOG_EVENT(e);</entry>
      <tran trig="ATTITUDE_GUAGE_START_REQ" target="../../1">
       <action brief="^CFM">LOG_EVENT(e);
me-&gt;PublishConfirmation(
    EVT_CAST(*e),
    ATTITUDE_GUAGE_START_CFM_SIG);</action>
       <tran_glyph conn="15,17,2,0,4,-6,4,9,4">
        <action box="-4,5,29,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ATTITUDE_GUAGE_STOP_REQ">
       <action brief="^CFM">LOG_EVENT(e);
me-&gt;PublishConfirmation(
    EVT_CAST(*e),
    ATTITUDE_GUAGE_STOP_CFM_SIG);</action>
       <tran_glyph conn="5,14,3,-1,30">
        <action box="4,-2,32,3"/>
       </tran_glyph>
      </tran>
      <state_glyph node="5,9,45,8">
       <entry box="1,2,6,2"/>
      </state_glyph>
     </state>
     <state_glyph node="2,5,91,57"/>
    </state>
    <state_diagram size="98,64"/>
   </statechart>
  </class>
  <class name="AttitudeDataEvt" superclass="StdEvents::Evt">
   <attribute name="m_acc" type="Acceleration" visibility="0x00" properties="0x00"/>
   <attribute name="m_angularRate" type="AngularRate" visibility="0x00" properties="0x00"/>
   <attribute name="m_field" type="MagneticField" visibility="0x00" properties="0x00"/>
   <operation name="AttitudeDataEvt" type="" visibility="0x00" properties="0x00">
    <parameter name="acc" type="Acceleration"/>
    <parameter name="angularRate" type="AngularRate"/>
    <parameter name="field" type="MagneticField"/>
    <code> : Evt(ATTITUDE_CHANGED_SIG)
    , m_acc(acc)
    , m_angularRate(angularRate)
    , m_field(field)</code>
   </operation>
  </class>
  <directory name="AttitudeGuage">
   <file name="AttitudeGuage.h">
    <text>#ifndef _AO_ATTITUDE_GUAGE_H
#define _AO_ATTITUDE_GUAGE_H

// STM32 Supporting Libs
#include &quot;stm32f4xx_hal.h&quot;
#include &quot;stm32f4xx_nucleo.h&quot;
#include &lt;stdbool.h&gt;

// QP Helpers
#include &quot;qpcpp.h&quot;
#include &quot;bsp.h&quot;
#include &quot;active_events.h&quot;
#include &quot;active_log.h&quot;

#include &quot;LSM6DS0_ACC_GYRO_driver.h&quot;
#include &quot;LSM6DS0_ACC_GYRO_driver_HL.h&quot;
#include &quot;component.h&quot;
#include &quot;x_nucleo_iks01a1_accelero.h&quot;
#include &quot;x_nucleo_iks01a1_gyro.h&quot;

#include &quot;Attitude.h&quot;
#include &quot;AttitudeUtils.h&quot;

//// CONSUMES EVENTS /////////////////////////
//    ATTITUDE_GUAGE_START_REQ_SIG
//    ATTITUDE_GUAGE_STOP_REQ_SIG
//    ATTITUDE_DATA_AVAILABLE_SIG
//// PRODUCES EVENTS /////////////////////////
//    ATTITUDE_GUAGE_START_CFM_SIG
//    ATTITUDE_GUAGE_COMPONENT_FAILED_SIG
//    ATTITUDE_GUAGE_STOP_CFM_SIG
//    ATTITUDE_CHANGED_SIG
//////////////////////////////////////////////


$declare(AttitudeGuage)

#endif // _AO_ATTITUDE_GUAGE_H</text>
   </file>
   <file name="AttitudeGuage.cpp">
    <text>#include &quot;AttitudeGuage.h&quot;

#include &quot;x_nucleo_iks01a1_accelero.h&quot;
#include &quot;active_config.h&quot;
#include &quot;app_ao_config.h&quot;
#include &quot;active_log.h&quot;

using namespace StdEvents;
using namespace QP;

$define(AttitudeGuage)</text>
   </file>
   <file name="Attitude.h">
    <text>#ifndef _AO_ATTITUDE_H
#define _AO_ATTITUDE_H

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

typedef struct {
    float x = 0.0f;
    float y = 0.0f;
    float z = 0.0f;
} AttitudeDim;

typedef AttitudeDim Acceleration; /* XYZ rates in meters per sec-square */
typedef AttitudeDim Velocity; /* XYZ rates in meters per sec */
typedef AttitudeDim Position; /* XYZ in meters*/

typedef AttitudeDim AngularAcc;  /* XYZ acc in degrees per sec-square */
typedef AttitudeDim AngularRate; /* XYZ rate in degrees per sec */
typedef AttitudeDim AngularPos; /* XYZ angles in degrees */

typedef AttitudeDim MagneticField; /* XYZ gauss*/

typedef float Altitude;

struct SixAxisAttitude {
    AngularRate  angularRate;
    Acceleration linearAcc;
};

struct NineAxisAttitude {
    AngularRate  angularRate;
    Acceleration linearAcc;
    MagneticField magneticStrength;
};

#ifdef __cplusplus
}
#endif

#endif // _AO_ATTITUDE_H
</text>
   </file>
   <file name="AttitudeUtils.h">
    <text>#ifndef _AO_ATTITUDE_UTILS_H
#define _AO_ATTITUDE_UTILS_H

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

#include &quot;stm32f4xx_hal.h&quot;
#include &quot;Attitude.h&quot;
#include &quot;component.h&quot;
#include &quot;LSM6DS0_ACC_GYRO_driver.h&quot;

#include &quot;MahonyAHRS.h&quot;
#include &quot;MadgwickAHRS.h&quot;

namespace Attitude {
class AttitudeUtils {
private:
    static int cycleCounterCount;
    static float cycleCounterAvg;
    static int counter;
    static float accSensitivity;
    static float gyroSensitivity;
    static float magSensitivity;
    static Q_cxyz q;
    static AngularPos orientation;
    static constexpr float ACCELERATION_DUE_TO_GRAVITY_METERS_PER_SEC_SQ = 9.8f;
    static HAL_StatusTypeDef ReadMagneticField(void *magHandle, MagneticField &amp;magField);
public:
    static status_t Initialize(DrvStatusTypeDef &amp; result, void **hhandle, void **magHandle, void **barHandle);
    static status_t InitializeBarometer(DrvStatusTypeDef &amp; result, void **barHandle);

    static status_t isGyroDataReady(void *handle);
    static status_t GetAttitude2(u8_t* gyro_acc_data, Acceleration &amp;acc, AngularRate &amp;angRate, MagneticField magField, Altitude altitude, Q_cxyz *attitude);
    static status_t StartDMATransfer(MagneticField &amp;magField, Altitude &amp;altitude, void *handle,  void *magHandle, void *barHandle, u8_t *buff, uint32_t length);

    static status_t ReadAltitude(void *barHandle, Altitude &amp;altitude);

    static status_t ResetAccSensitivity( void *handle );
    static status_t ResetGyroSensitivity( void *handle );
    static status_t ResetMagSensitivity( void *handle );
};

}// namespace

#ifdef __cplusplus
}
#endif

#endif // _AO_ATTITUDE_UTILS_H</text>
   </file>
  </directory>
 </package>
</model>
